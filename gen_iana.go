// Copyright 2013 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// +build ignore

//go:generate go run gen_iana.go

// This program generates internet protocol constants and tables by
// reading IANA protocol registries.

package main

import (
	"bytes"
	"encoding/xml"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"strconv"
	"strings"
)

var registries = []struct {
	url   string
	parse func(io.Writer, io.Reader) error
}{
	{
		"https://www.iana.org/assignments/protocol-numbers/protocol-numbers.xml",
		parseProtocolNumbers,
	},
	{
		"https://www.iana.org/assignments/service-names-port-numbers/service-names-port-numbers.xml",
		parsePortNumbers,
	},
}

func main() {
	var bb bytes.Buffer
	fmt.Fprintf(&bb, "// go generate gen_iana.go\n")
	fmt.Fprintf(&bb, "// GENERATED BY THE COMMAND ABOVE; DO NOT EDIT\n")
	fmt.Fprintf(&bb, "\n")
	fmt.Fprintf(&bb, "// Package iana provides protocol number resources managed by the Internet Assigned Numbers Authority (IANA).\n")
	fmt.Fprintf(&bb, "package main\n")
	fmt.Fprintf(&bb, "\n")

	for _, r := range registries {
		resp, err := http.Get(r.url)
		if err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(1)
		}
		defer resp.Body.Close()
		if resp.StatusCode != http.StatusOK {
			fmt.Fprintf(os.Stderr, "got HTTP status code %v for %v\n", resp.StatusCode, r.url)
			os.Exit(1)
		}
		if err := r.parse(&bb, resp.Body); err != nil {
			fmt.Fprintln(os.Stderr, err)
			os.Exit(1)
		}
		fmt.Fprintf(&bb, "\n")
	}
	b, err := format.Source(bb.Bytes())
	if err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
	if err := ioutil.WriteFile("iana_maps.go", b, 0644); err != nil {
		fmt.Fprintln(os.Stderr, err)
		os.Exit(1)
	}
}

func parseProtocolNumbers(w io.Writer, r io.Reader) error {
	dec := xml.NewDecoder(r)
	var pn protocolNumbers
	if err := dec.Decode(&pn); err != nil {
		return err
	}
	prs := pn.escape()
	prs = append([]canonProtocolRecord{{
		Name:  "ip",
		Descr: "IPv4 encapsulation, pseudo protocol number",
		Value: 0,
	}}, prs...)

	fmt.Fprintf(w, "// %s, Updated: %s\n", pn.Title, pn.Updated)

	//fmt.Fprintf(w, "const (\n")
	//for _, pr := range prs {
	//	if pr.Name == "" {
	//		continue
	//	}
	//	fmt.Fprintf(w, "IanaProtocol%s = %d", pr.Name, pr.Value)
	//	s := pr.Descr
	//	if s == "" {
	//		s = pr.OrigName
	//	}
	//	fmt.Fprintf(w, "// %s\n", s)
	//}
	//fmt.Fprintf(w, ")\n")

	fmt.Fprintf(w, "var IanaProtocol = map[uint8]string{\n")
	for i, pr := range prs {
		if func(prs []canonProtocolRecord, pNum int) bool {
			for _, pr := range prs {
				if pr.Value == pNum {
					return true
				}
			}

			return false
		}(prs[:i], pr.Value) {
			continue
		}

		if pr.Name == "" {
			continue
		}
		fmt.Fprintf(w, "%d: \"%s\",", pr.Value, pr.Name)
		s := pr.Descr
		if s == "" {
			s = pr.OrigName
		}
		fmt.Fprintf(w, "// %s\n", s)
	}
	fmt.Fprintf(w, "}\n")
	return nil
}

type protocolNumbers struct {
	XMLName  xml.Name `xml:"registry"`
	Title    string   `xml:"title"`
	Updated  string   `xml:"updated"`
	RegTitle string   `xml:"registry>title"`
	Note     string   `xml:"registry>note"`
	Records  []struct {
		Value string `xml:"value"`
		Name  string `xml:"name"`
		Descr string `xml:"description"`
	} `xml:"registry>record"`
}

type canonProtocolRecord struct {
	OrigName string
	Name     string
	Descr    string
	Value    int
}

func (pn *protocolNumbers) escape() []canonProtocolRecord {
	prs := make([]canonProtocolRecord, len(pn.Records))
	sr := strings.NewReplacer(
		" ", "-",
		"_", "-",
	)
	for i, pr := range pn.Records {
		if pr.Name == "" {
			continue
		}
		if strings.Contains(pr.Name, "Deprecated") ||
			strings.Contains(pr.Name, "deprecated") {
			continue
		}
		prs[i].OrigName = pr.Name
		switch pr.Name {
		case "ISIS over IPv4":
			prs[i].Name = "isis"
		default:
			prs[i].Name = strings.ToLower(sr.Replace(pr.Name))
		}
		ss := strings.Split(pr.Descr, "\n")
		for i := range ss {
			ss[i] = strings.TrimSpace(ss[i])
		}
		if len(ss) > 1 {
			prs[i].Descr = strings.Join(ss, " ")
		} else {
			prs[i].Descr = ss[0]
		}
		prs[i].Value, _ = strconv.Atoi(pr.Value)
	}
	return prs
}

func parsePortNumbers(w io.Writer, r io.Reader) error {
	dec := xml.NewDecoder(r)
	var pn portNumbers
	if err := dec.Decode(&pn); err != nil {
		return err
	}
	prs := pn.escape()

	fmt.Fprintf(w, "// %s, Updated: %s\n", pn.Title, pn.Updated)

	//fmt.Fprintf(w, "const (\n")
	//for _, pr := range prs {
	//	if pr.Name == "" {
	//		continue
	//	}
	//	fmt.Fprintf(w, "IanaProtocol%s = %d", pr.Name, pr.Value)
	//	s := pr.Descr
	//	if s == "" {
	//		s = pr.OrigName
	//	}
	//	fmt.Fprintf(w, "// %s\n", s)
	//}
	//fmt.Fprintf(w, ")\n")

	prsMap := make(map[string][]canonPortRecord)
	for _, pr := range prs {
		pprs, ok := prsMap[pr.Protocol]
		if !ok {
			prsMap[pr.Protocol] = []canonPortRecord{pr}
		} else {
			prsMap[pr.Protocol] = append(pprs, pr)
		}
	}

	fmt.Fprintf(w, "var IanaPort = map[string]map[uint16]string{\n")

	for p, prs := range prsMap {
		if p == "" {
			continue
		}
		fmt.Fprintf(w, "\"%s\": {\n", p)
		for i, pr := range prs {
			if func(prs []canonPortRecord, pNum int) bool {
				for _, pr := range prs {
					if pr.Number == pNum {
						return true
					}
				}

				return false
			}(prs[:i], pr.Number) {
				continue
			}

			if pr.Name == "" {
				continue
			}
			fmt.Fprintf(w, "%d: \"%s\",", pr.Number, pr.Name)
			s := pr.Descr
			if s == "" {
				s = pr.OrigName
			}
			fmt.Fprintf(w, "// %s\n", s)
		}
		fmt.Fprintf(w, "},\n")
	}
	fmt.Fprintf(w, "}\n")
	return nil
}

type portNumbers struct {
	XMLName xml.Name `xml:"registry"`
	Title   string   `xml:"title"`
	Updated string   `xml:"updated"`
	Records []struct {
		Name     string `xml:"name"`
		Protocol string `xml:"protocol"`
		Number   string `xml:"number"`
		Descr    string `xml:"description"`
	} `xml:"record"`
}

type canonPortRecord struct {
	OrigName string
	Name     string
	Descr    string
	Protocol string
	Number   int
}

func (pn *portNumbers) escape() []canonPortRecord {
	prs := make([]canonPortRecord, len(pn.Records))
	sr := strings.NewReplacer(
		" ", "-",
		"_", "-",
	)
	for i, pr := range pn.Records {
		if pr.Name == "" {
			continue
		}
		if strings.Contains(pr.Descr, "Deprecated") ||
			strings.Contains(pr.Descr, "deprecated") ||
			strings.Contains(pr.Descr, "Unassigned") ||
			strings.Contains(pr.Descr, "unassigned") {
			continue
		}
		prs[i].OrigName = pr.Name
		switch pr.Name {
		case "Apple Remote Desktop (Net Assistant)":
			prs[i].Name = "apple-remote-desktop"
		case "Escale (Newton Dock)":
			prs[i].Name = "escale"
		default:
			prs[i].Name = strings.ToLower(sr.Replace(pr.Name))
		}
		ss := strings.Split(pr.Descr, "\n")
		for i := range ss {
			ss[i] = strings.TrimSpace(ss[i])
		}
		if len(ss) > 1 {
			prs[i].Descr = strings.Join(ss, " ")
		} else {
			prs[i].Descr = ss[0]
		}
		prs[i].Protocol = strings.ToLower(pr.Protocol)
		prs[i].Number, _ = strconv.Atoi(pr.Number)
	}
	return prs
}
